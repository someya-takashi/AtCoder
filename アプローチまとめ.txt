・問題の言い換え
K個前と同じ手は使用できない→i,i+K...のようなmodKの区間に分割し、区間間は独立だが、同じ区間で前と同じ手は使用できないと言い換える
modKの組み合わせはK通り（Kが小さいなら制約を小さくすることができる）

・場合分けや状態遷移が複雑な問題
深さ優先探索で全探索できないか検討
例：グリッドの

・文字列
辞書順に出力→先頭から決めることが多い

・mod計算
mod NならNを円周上に並べて図示すると考えやすいかも

・数列問題 
累積和（左右累積和、しゃくとり法） # O(N)
ソート　# (ONlogN)
二分探索 # ソート＋O(logN)
絶対値外す、シグマ、法則を見つけてO(1)を作る

・最小値、最大値
全探索
動的計画法

・組み合わせ数え上げ
高速コンビネーション
mod KならK内でループするまで探索
素因数分解
約数列挙
式変形
パーミュテーション
重複組み合わせは nHr = (n+r-1)Cr （n個の〇をr個の棒でしきるイメージ）

・素因数分解
素因数毎に独立に考える、素因数の指数に注目する（ABC 110 D）


・グラフ
幅優先探索
深さ優先探索
ダイクストラ

・全探索
二重ループの回避（累積和、しゃくとり法、式変形、両辺をiとjに分離）
bit全探索
グラフ探索

・約数
Nの約数の数、例：720を素因数分解すると 2**4*3**2**5 それぞれの素数の指数+1を掛け合わせて、5*3*2=30個
これを利用するとN!のような複数の数の積からなる数の約数の数を求めることができる

・UnionFind
連結要素をカウントするなど、いろいろな問題へ応用できる
※uniteで統合した後に連結要素の大きさを求めるとき、findをするかfindを含んだ関数を使って経路圧縮しておく

・ゲーム問題
1. 後ろから勝ち負けを探索する
2. Grundy数を求める
3. ad hocな必勝法を見つける