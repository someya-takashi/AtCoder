# https://atcoder.jp/contests/abc129/tasks/abc129_e
# あるLが与えられ、それを超えないように走査する場合
# 例：L = 100100 を大きい桁から桁毎に走査する
# 1桁目は1なので、1を選ぶと2桁目以降の選び方によってLを超える可能性があるので
# （1xxxxx >= 100100 = L , x = 0 or 1）「L未満が未確定」のフラグを付ける
# 1桁目に0を選ぶと、2桁目以降をどのように選んでも、確実にLを超えない(L = 100100 > 0xxxxx, x = 0 or 1)ので、
# 「L未満になることが確定」のフラグを付ける
# dpの持ち方は、dp[i桁目が][L未満か（0 = 未確定, 1 = 確定）]

# 遷移はまずL未満が確定している状態からの遷移はLのi桁目が1か0に関わらず可能なので、
# 1を選んだときと0を選んだときの組み合わせを合算する
# Lのi桁目が1で未確定からの遷移は、1を選ぶと未確定→未確定への遷移
# 0を選ぶと、未確定から確定への遷移になる
# Lのi桁目が0で未確定からの遷移は、1はLを超えるので選べない（遷移不可）
# 0を選ぶと未確定→未確定への遷移になる

# 条件を満たすa, bのi桁目の候補は(0, 0), (1, 0), (0, 1)の3通り

# 入力：2進数で最大10**5桁
L = input()
mod = 10**9+7

N = len(L)

# dp[桁目][L未満が確定しているか]
dp = [[0] * 2 for _ in range(N+1)]
dp[0][0] = 1

for i in range(N):
    ni = int(L[i])

    # 確定→確定の遷移
    # ai, bi : aとbのi桁目（0 or 1）
    # (ai, bi) = (0, 0), (1, 0), (0, 1)の3通り全てが選べる
    dp[i+1][1] += dp[i][1]*3
    dp[i+1][1] %= mod

    if ni == 1:
        # (1, 0), (0, 1)の2通りが選択可能
        dp[i+1][0] += dp[i][0]*2
        dp[i+1][0] %= mod
        # (0, 0)を選ぶと未確定→確定へ遷移する
        dp[i+1][1] += dp[i][0]
        dp[i+1][1] %= mod
    else:
        # 未確定の状態から(1, 0), (0, 1)を選ぶとLを超えてしまうので選べない
        # (0, 0)のみ
        dp[i+1][0] += dp[i][0]
        dp[i+1][0] %= mod

print((dp[N][0]+dp[N][1])%mod)