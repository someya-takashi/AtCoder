"""
先手はスコアを最大化したい
後手はスコアを最小化したい

深さ優先探索などでゲーム木（ゲームの盤面などの状態）探索を行う
先手と後手の状態を変数などで管理し、先手の手番ではスコア最大のゲームを返し、
後手の手番ではスコア最小の手番を返す


例：ABS
N 枚のカードからなる山札があります。カードにはそれぞれ数が書かれており， 
上から i 枚目には a i が書かれています。 この山札を使い，X さんと Y さんが 2 人でゲームをします。
X, Y さんは最初， Z , W が書かれたカードを持っています。 そして X さんから交互に以下を行います。
山札から何枚かカードを引く。そして今持っているカードを捨て，最後に引いたカードを代わりに持つ。
ただし，必ず 1 枚は引かなくてはならない。 
山札がなくなるとゲームは終了で， 2 人の持っているカードに書かれた数の差の絶対値がこのゲームのスコアになります。
X さんはスコアを最大化するように，Y さんはスコアを最小化するようにゲームをプレイした時，
スコアはいくつになるでしょうか？

dp[i][turn] : 上からi番目まで引いて手番がturnのときのスコア
深さ優先探索で先手は最大、後手は最小を返すように遷移していったとき、
dp[0][先手]が答え
"""

import sys
sys.setrecursionlimit(10000000)

# Z, Wは初期の手札
N, Z, W = map(int, input().split())
# i = 0は何も引いてない状態を表したい（0-indexだとA[0]は上から1枚目を表してしまうので）、
# ダミーで[0]を追加した
A = [0] + list(map(int, input().split()))

# メモ化用配列、Noneで初期化
dp = [[None] * 2 for _ in range(N+1)]

# 上からi番目まで引いていて、手番がturn、先手の手札がx、後手の手札がyのときのdfs
def dfs(i, turn, x, y):
    if i == N:
        dp[i][turn] = abs(x-y)
        return abs(x-y)
    
    if dp[i][turn] is not None:
        return dp[i][turn]
    
    # 手番が先手の場合、探索したゲーム木の最大を返す
    if turn == 0:
        ret = -10**18
        for j in range(i+1, N+1):
            xj = A[j]
            ret = max(ret, dfs(j, 1, xj, y))
    # 手番が後手の場合、探索したゲームの最小を返す
    else:
        ret = 10**18
        for j in range(i+1, N+1):
            yj = A[j]
            ret = min(ret, dfs(j, 0, x, yj))
    
    # メモ化
    dp[i][turn] = ret
    return ret

# 何も引いてない状態で先手からスタート
dfs(0, 0, Z, W)

print(dp[0][0])